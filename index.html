<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Solar System Explorer VR (Meta Quest 3)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@21.0.0/dist/tween.umd.js"></script>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        canvas { display: block; }
        #vr-button { position: absolute; bottom: 20px; right: 20px; z-index: 1000; }
    </style>
</head>
<body>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        // Core Components
        let scene, camera, renderer, clock;
        let solarGroup, cockpit; // Groups for managing objects
        let listener, ambientSound, warpSound, uiBeepSound, launchSound;
        const textureLoader = new THREE.TextureLoader();

        // VR & Interaction
        let controller1, controller2;
        let hand1, hand2;
        let handModelFactory, controllerModelFactory;
        const raycaster = new THREE.Raycaster();
        let grabbedObject = null;
        let selectedTarget = null;
        let activeProbe = null;

        // State & Physics
        let flightSpeed = 0;
        const celestialBodies = [];
        const launchableProbes = [];
        const G = 6.67430e-11; // Gravitational constant

        // Scales and Constants
        const KM_IN_AU = 149.6e6;
        const LY_IN_AU = 63241.1;
        const UNIVERSE_SCALE = 100; // 1 AU = 100 world units
        const BODY_SCALE = UNIVERSE_SCALE / KM_IN_AU;
        const BASE_ORBIT_SPEED = 0.05; // Scaled for smooth visuals

        // UI Panels
        let navPanel, infoPanel, probePanel;
        let gravityArrow;

        // Data
        const solarSystemData = [
            { name: 'Sun', radius: 696340, mass: 1.989e30, color: 0xfff000, funFacts: [ "The Sun accounts for 99.86% of the mass in the solar system.", "The Sun's core temperature is about 15 million degrees Celsius.", "A solar flare can release the equivalent of millions of 100-megaton hydrogen bombs." ] },
            { name: 'Mercury', radius: 2440, mass: 3.301e23, a: 57.9, e: 0.205, period: 88, inclination: 7.0, axialTilt: 0.03, funFacts: [ "Mercury has the most eccentric orbit of any planet in the Solar System.", "A day on Mercury is longer than its year.", "Ice may exist in permanently shadowed craters at its poles." ] },
            { name: 'Venus', radius: 6052, mass: 4.867e24, a: 108.2, e: 0.007, period: 224.7, inclination: 3.4, axialTilt: 177.4, funFacts: [ "Venus rotates backwards compared to other planets.", "It's the hottest planet, with surface temperatures hot enough to melt lead.", "Its surface pressure is over 90 times that of Earth." ] },
            { name: 'Earth', radius: 6371, mass: 5.972e24, a: 149.6, e: 0.017, period: 365.2, inclination: 0.0, axialTilt: 23.4, funFacts: [ "Earth is the only known planet to harbor life.", "Its magnetic field protects it from harmful solar wind.", "Earthâ€™s rotation is gradually slowing down." ], moons: [
                { name: 'Moon', radius: 1737, mass: 7.342e22, a: 0.384, e: 0.055, period: 27.3, inclination: 5.1, funFacts: ["The Moon is drifting away from Earth by about 3.8 cm per year.", "It is the 5th largest moon in the solar system.", "The Moon has 'moonquakes' caused by the Earth's gravitational pull."] }
            ]},
            { name: 'Mars', radius: 3390, mass: 6.417e23, a: 227.9, e: 0.094, period: 687, inclination: 1.8, axialTilt: 25.2, funFacts: [ "Mars has the tallest volcano in the solar system, Olympus Mons.", "It has the largest dust storms, which can cover the entire planet.", "Mars has two small moons, Phobos and Deimos." ] },
            { name: 'Jupiter', radius: 69911, mass: 1.898e27, a: 778.6, e: 0.049, period: 4331, inclination: 1.3, axialTilt: 3.1, funFacts: [ "Jupiter is so big that all other planets could fit inside it.", "The Great Red Spot is a storm that has been raging for centuries.", "Jupiter has the shortest day of any planet (about 10 hours)." ], moons: [
                { name: 'Io', radius: 1821, mass: 8.93e22, a: 0.421, e: 0.004, period: 1.77, inclination: 0.05, funFacts: ["Io is the most volcanically active body in the solar system."] },
                { name: 'Europa', radius: 1560, mass: 4.8e22, a: 0.671, e: 0.009, period: 3.55, inclination: 0.47, funFacts: ["Europa may have a subsurface saltwater ocean, making it a candidate for life."] },
                { name: 'Ganymede', radius: 2634, mass: 1.48e23, a: 1.070, e: 0.001, period: 7.15, inclination: 0.20, funFacts: ["Ganymede is the largest moon in the solar system, bigger than Mercury."] },
                { name: 'Callisto', radius: 2410, mass: 1.08e23, a: 1.882, e: 0.007, period: 16.69, inclination: 0.20, funFacts: ["Callisto is one of the most heavily cratered objects in the solar system."] }
            ]},
            { name: 'Saturn', radius: 58232, mass: 5.683e26, a: 1433.5, e: 0.057, period: 10747, inclination: 2.5, axialTilt: 26.7, funFacts: [ "Saturn's rings are made of ice and rock particles.", "Saturn is less dense than water; it would float.", "Winds on Saturn can reach 1,800 km/h." ], moons: [
                { name: 'Titan', radius: 2575, mass: 1.345e23, a: 1.221, e: 0.029, period: 15.9, inclination: 0.33, funFacts: ["Titan is the only moon with a thick atmosphere and liquid on its surface."] },
                { name: 'Enceladus', radius: 252, mass: 1.08e20, a: 0.238, e: 0.005, period: 1.4, inclination: 0.02, funFacts: ["Enceladus sprays water ice geysers from its south pole into space."] }
            ]},
            { name: 'Uranus', radius: 25362, mass: 8.681e25, a: 2872.5, e: 0.046, period: 30589, inclination: 0.8, axialTilt: 97.8, funFacts: [ "Uranus is tilted on its side, likely from a massive collision.", "A season on Uranus lasts for more than 20 Earth years.", "It is the coldest planet in the solar system." ] },
            { name: 'Neptune', radius: 24622, mass: 1.024e26, a: 4495.1, e: 0.011, period: 59800, inclination: 1.8, axialTilt: 28.3, funFacts: [ "Neptune has the strongest winds in the solar system.", "It was the first planet located through mathematical prediction.", "Its largest moon, Triton, orbits in the opposite direction of the planet's rotation." ] },
            { name: 'Pluto', type: 'Dwarf Planet', radius: 1188, mass: 1.309e22, a: 5906.4, e: 0.249, period: 90560, inclination: 17.2, axialTilt: 122.5, funFacts: [ "Pluto was reclassified as a dwarf planet in 2006.", "Its orbit is so eccentric it sometimes comes closer to the Sun than Neptune.", "It has a large, heart-shaped glacier made of nitrogen ice." ] }
        ];

        const probesData = [
            { name: 'Voyager 1', distAU: 167.3, declination: 12.1, rightAscension: 267.0 },
            { name: 'Voyager 2', distAU: 139.3, declination: -55.5, rightAscension: 299.1 },
            { name: 'Pioneer 10', distAU: 139.0, declination: 25.6, rightAscension: 75.8 },
            { name: 'New Horizons', distAU: 60.5, declination: -21.4, rightAscension: 290.0 }
        ];

        const starData = [
            { name: 'Proxima Centauri', distLY: 4.24, color: 0xff6a3d, ra: 222.9, dec: -62.6 },
            { name: 'Alpha Centauri A', distLY: 4.37, color: 0xfff4e1, ra: 219.9, dec: -60.8 },
            { name: 'Alpha Centauri B', distLY: 4.37, color: 0xffd9a1, ra: 219.9, dec: -60.8 },
            { name: 'Sirius', distLY: 8.6, color: 0xcad7ff, ra: 101.3, dec: -16.7 }
        ];
        
        // Textures
        const planetTextures = {
            Sun: { map: textureLoader.load('textures/sun.jpg') },
            Mercury: { map: textureLoader.load('textures/mercury.jpg') },
            Venus: { map: textureLoader.load('textures/venus_surface.jpg'), atmosphere: textureLoader.load('textures/venus_atmosphere.jpg') },
            Earth: { map: textureLoader.load('textures/earth_daymap.jpg'), nightMap: textureLoader.load('textures/earth_lights.png'), clouds: textureLoader.load('textures/earth_clouds.jpg') },
            Mars: { map: textureLoader.load('textures/mars.jpg') },
            Jupiter: { map: textureLoader.load('textures/jupiter.jpg') },
            Saturn: { map: textureLoader.load('textures/saturn.jpg'), ring: textureLoader.load('textures/saturn_ring_alpha.png') },
            Uranus: { map: textureLoader.load('textures/uranus.jpg') },
            Neptune: { map: textureLoader.load('textures/neptune.jpg') },
            Moon: { map: textureLoader.load('textures/moon.jpg') },
            Pluto: { map: textureLoader.load('textures/pluto.jpg') } // Assuming a texture exists
        };

        // --- INITIALIZATION ---
        function init() {
            // Core setup
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5e7);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // Audio
            listener = new THREE.AudioListener();
            camera.add(listener);

            // Scenegraph groups
            solarGroup = new THREE.Group();
            scene.add(solarGroup);
            cockpit = new THREE.Group();
            scene.add(cockpit);
            camera.position.set(0, 1.6, 0); // Player eye height

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);
            
            // Build scene
            createStarfield();
            createSolarSystem();
            createDeepSpaceProbes();
            createCockpit();
            setupControllers();
            loadAudio();

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
            
            // Start render loop
            renderer.setAnimationLoop(animate);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- AUDIO ---
        function loadAudio() {
            const audioLoader = new THREE.AudioLoader();
            audioLoader.load('sounds/ambience.mp3', buffer => {
                ambientSound = new THREE.Audio(listener);
                ambientSound.setBuffer(buffer);
                ambientSound.setLoop(true);
                ambientSound.setVolume(0.2);
                ambientSound.play();
            });
            audioLoader.load('sounds/warp.mp3', buffer => {
                warpSound = new THREE.Audio(listener);
                warpSound.setBuffer(buffer);
                warpSound.setVolume(0.8);
            });
            audioLoader.load('sounds/beep.mp3', buffer => {
                uiBeepSound = new THREE.Audio(listener);
                uiBeepSound.setBuffer(buffer);
                uiBeepSound.setVolume(0.4);
            });
            audioLoader.load('sounds/launch.mp3', buffer => { // Assuming a launch sound exists
                launchSound = new THREE.Audio(listener);
                launchSound.setBuffer(buffer);
                launchSound.setVolume(0.6);
            });
        }
        
        // --- SCENE CREATION ---

        function createStarfield() {
            // Layer 1: Distant, dense stars
            const starGeo1 = new THREE.BufferGeometry();
            const starVertices1 = [];
            for (let i = 0; i < 15000; i++) {
                const x = THREE.MathUtils.randFloatSpread(20000);
                const y = THREE.MathUtils.randFloatSpread(20000);
                const z = THREE.MathUtils.randFloatSpread(20000);
                starVertices1.push(x, y, z);
            }
            starGeo1.setAttribute('position', new THREE.Float32BufferAttribute(starVertices1, 3));
            const starMat1 = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 2.5, sizeAttenuation: false });
            const stars1 = new THREE.Points(starGeo1, starMat1);
            solarGroup.add(stars1);

            // Layer 2: Closer, brighter stars
            const starGeo2 = new THREE.BufferGeometry();
            const starVertices2 = [];
            for (let i = 0; i < 1000; i++) {
                const x = THREE.MathUtils.randFloatSpread(15000);
                const y = THREE.MathUtils.randFloatSpread(15000);
                const z = THREE.MathUtils.randFloatSpread(15000);
                starVertices2.push(x, y, z);
            }
            starGeo2.setAttribute('position', new THREE.Float32BufferAttribute(starVertices2, 3));
            const starMat2 = new THREE.PointsMaterial({ color: 0xffffff, size: 5, sizeAttenuation: false });
            const stars2 = new THREE.Points(starGeo2, starMat2);
            solarGroup.add(stars2);
        }

        function createSolarSystem() {
            // Sun
            const sunData = solarSystemData.find(d => d.name === 'Sun');
            const sunVisualRadius = sunData.radius * BODY_SCALE;
            const sunGeo = new THREE.SphereGeometry(sunVisualRadius, 64, 32);
            const sunMat = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 1.0 },
                    color: { value: new THREE.Color(0xfff000) },
                    texture1: { value: planetTextures.Sun.map }
                },
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 color;
                    uniform sampler2D texture1;
                    varying vec2 vUv;
                    
                    void main() {
                        vec2 uv = vUv;
                        float noise = (texture2D(texture1, uv * vec2(2.0, 1.0) + vec2(time * 0.01, 0.0)).r + 
                                       texture2D(texture1, uv * vec2(1.0, 2.0) - vec2(0.0, time * 0.015)).g) * 0.5;
                        float rim = 1.0 - smoothstep(0.4, 1.0, length(uv - 0.5));
                        gl_FragColor = vec4(color * (noise + 0.5) * rim, 1.0);
                    }
                `
            });
            const sunMesh = new THREE.Mesh(sunGeo, sunMat);
            const sunLight = new THREE.PointLight(0xffffff, 3.5, 0, 0);
            sunMesh.add(sunLight);
            const sunObject = { mesh: sunMesh, data: sunData, isSun: true };
            celestialBodies.push(sunObject);
            solarGroup.add(sunMesh);

            // Planets and Moons
            solarSystemData.forEach(data => {
                if (data.isSun) return;

                const visualRadius = data.radius * BODY_SCALE * 10; // Inflate for visibility
                let material;
                
                if (data.name === 'Earth') {
                    material = new THREE.MeshPhongMaterial({
                        map: planetTextures.Earth.map,
                        emissiveMap: planetTextures.Earth.nightMap,
                        emissive: new THREE.Color(0xffffff),
                        emissiveIntensity: 1.5,
                        shininess: 10
                    });
                } else if (planetTextures[data.name]?.map) {
                     material = new THREE.MeshStandardMaterial({ map: planetTextures[data.name].map, roughness: 0.9 });
                } else {
                    material = new THREE.MeshStandardMaterial({ color: new THREE.Color(data.color || 0xffffff), roughness: 0.9 });
                }

                const mesh = new THREE.Mesh(new THREE.SphereGeometry(visualRadius, 32, 16), material);
                const bodyObject = { mesh, data };
                celestialBodies.push(bodyObject);
                
                // Add clouds, atmospheres, rings
                if (data.name === 'Earth') {
                    const cloudMesh = new THREE.Mesh(
                        new THREE.SphereGeometry(visualRadius * 1.02, 32, 16),
                        new THREE.MeshPhongMaterial({ map: planetTextures.Earth.clouds, transparent: true, opacity: 0.6 })
                    );
                    mesh.add(cloudMesh);
                    bodyObject.clouds = cloudMesh;
                } else if (data.name === 'Venus') {
                    mesh.add(new THREE.Mesh(
                        new THREE.SphereGeometry(visualRadius * 1.02, 32, 16),
                        new THREE.MeshPhongMaterial({ map: planetTextures.Venus.atmosphere, transparent: true, opacity: 0.7 })
                    ));
                } else if (data.name === 'Saturn') {
                    const ringGeo = new THREE.RingGeometry(visualRadius * 1.2, visualRadius * 2.2, 64);
                    const ringUv = ringGeo.attributes.uv;
                    const pos = ringGeo.attributes.position;
                    for (let i = 0; i < pos.count; i++) {
                        const v = (pos.getX(i)) / (visualRadius * 2.2);
                        ringUv.setX(i, v);
                    }
                    const ringMat = new THREE.MeshBasicMaterial({
                        map: planetTextures.Saturn.ring,
                        color: 0xdddddd,
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9
                    });
                    const ringMesh = new THREE.Mesh(ringGeo, ringMat);
                    ringMesh.rotation.x = Math.PI / 2;
                    mesh.add(ringMesh);
                }

                // Orbital mechanics setup
                const orbitalSystem = new THREE.Object3D();
                orbitalSystem.rotation.y = THREE.MathUtils.degToRad(data.lonAscNode || 0);
                const orbitalPlane = new THREE.Object3D();
                orbitalPlane.rotation.x = THREE.MathUtils.degToRad(data.inclination);
                orbitalSystem.add(orbitalPlane);
                orbitalPlane.add(mesh);
                solarGroup.add(orbitalSystem);

                bodyObject.orbitalSystem = orbitalSystem;
                mesh.rotation.z = THREE.MathUtils.degToRad(data.axialTilt);
                bodyObject.currentMeanAnomaly = THREE.MathUtils.degToRad(data.meanAnomalyEpoch || Math.random() * 360);

                // Moons
                if (data.moons) {
                    data.moons.forEach(moonData => createMoon(moonData, bodyObject));
                }
            });
        }
        
        function createMoon(moonData, parentBody) {
             const visualRadius = Math.max(0.1, moonData.radius * BODY_SCALE * 100); // Exaggerate small moons
             const material = planetTextures[moonData.name]?.map 
                ? new THREE.MeshStandardMaterial({ map: planetTextures[moonData.name].map, roughness: 0.9 })
                : new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.9 });

             const moonMesh = new THREE.Mesh(new THREE.SphereGeometry(visualRadius, 16, 8), material);
             const moonObject = { mesh: moonMesh, data: moonData, isMoon: true, parentBody };
             celestialBodies.push(moonObject);

             const orbitalSystem = new THREE.Object3D();
             orbitalSystem.rotation.y = THREE.MathUtils.degToRad(moonData.lonAscNode || Math.random() * 360);
             const orbitalPlane = new THREE.Object3D();
             orbitalPlane.rotation.x = THREE.MathUtils.degToRad(moonData.inclination);
             orbitalSystem.add(orbitalPlane);
             parentBody.mesh.add(orbitalSystem);
             orbitalPlane.add(moonMesh);

             moonObject.orbitalSystem = orbitalSystem;
             moonObject.currentMeanAnomaly = THREE.MathUtils.degToRad(moonData.meanAnomalyEpoch || Math.random() * 360);
        }

        function createDeepSpaceProbes() {
             probesData.forEach(probeData => {
                const probeMesh = new THREE.Group(); // Placeholder for a real model
                probeMesh.add(new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshStandardMaterial({color: 0xffffff})));
                const dist = probeData.distAU * UNIVERSE_SCALE;
                const raRad = THREE.MathUtils.degToRad(probeData.rightAscension);
                const decRad = THREE.MathUtils.degToRad(probeData.declination);
                probeMesh.position.set(
                    dist * Math.cos(decRad) * Math.cos(raRad),
                    dist * Math.sin(decRad),
                    dist * Math.cos(decRad) * Math.sin(raRad)
                );
                solarGroup.add(probeMesh);
                celestialBodies.push({ mesh: probeMesh, data: probeData, isProbe: true });
            });
        }

        function createCockpit() {
            // Main structure
            const cabinGeo = new THREE.CylinderGeometry(1.5, 1.5, 2.5, 32, 1, true);
            const cabinMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9, roughness: 0.3, side: THREE.DoubleSide });
            const cabinMesh = new THREE.Mesh(cabinGeo, cabinMat);
            cabinMesh.geometry.translate(0, 0.2, 0);
            cockpit.add(cabinMesh);

            // Glass
            const glassGeo = new THREE.SphereGeometry(1.45, 32, 16, 0, Math.PI * 2, 0, Math.PI / 1.5);
            const glassMat = new THREE.MeshPhysicalMaterial({ color: 0xadd8e6, transmission: 1.0, roughness: 0.05, thickness: 0.2 });
            const glassMesh = new THREE.Mesh(glassGeo, glassMat);
            glassMesh.position.y = 0.5;
            cockpit.add(glassMesh);

            // --- Control Panels ---
            const panelGeo = new THREE.PlaneGeometry(0.8, 0.6);
            
            // Navigation Panel
            navPanel = createUIPanel(panelGeo, { x: -1, y: 1.1, z: -1.2 }, {y: 0.4});
            navPanel.userData.type = 'navigation';
            cockpit.add(navPanel);
            
            // Information Panel
            infoPanel = createUIPanel(panelGeo, { x: 0, y: 1.1, z: -1.3 }, {y: 0});
            infoPanel.userData.type = 'information';
            cockpit.add(infoPanel);

            // Probe Control Panel
            probePanel = createUIPanel(panelGeo, { x: 1, y: 1.1, z: -1.2 }, {y: -0.4});
            probePanel.userData.type = 'probe_control';
            cockpit.add(probePanel);
            
            // --- Flight Controls ---
            const stickBase = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.1, 16), cabinMat);
            stickBase.position.set(0.5, 0.7, -0.8);
            cockpit.add(stickBase);
            const flightStick = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.3, 16), new THREE.MeshStandardMaterial({color: 0xaa0000}));
            flightStick.position.y = 0.2;
            flightStick.userData = { type: 'flightStick', baseRotation: new THREE.Quaternion() };
            stickBase.add(flightStick);

            const throttleBase = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.05, 0.4), cabinMat);
            throttleBase.position.set(-0.5, 0.75, -0.8);
            cockpit.add(throttleBase);
            const throttleLever = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.2, 0.08), new THREE.MeshStandardMaterial({color: 0x00aa00}));
            throttleLever.position.z = 0.15; // Start at zero speed
            throttleLever.userData = { type: 'throttle', minZ: -0.15, maxZ: 0.15 };
            throttleBase.add(throttleLever);
            
            // --- Gravitational Pull Visualizer ---
            gravityArrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,-1), new THREE.Vector3(0,0,0), 0.5, 0xffff00);
            gravityArrow.position.set(0, 1.5, -2);
            gravityArrow.visible = false;
            cockpit.add(gravityArrow);
        }

        function createUIPanel(geometry, position, rotation) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 384;
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.9 });
            const panel = new THREE.Mesh(geometry, material);
            panel.position.set(position.x, position.y, position.z);
            panel.rotation.y = rotation.y;
            panel.userData.canvas = canvas;
            panel.userData.context = canvas.getContext('2d');
            panel.userData.texture = texture;
            return panel;
        }

        function createLaunchableProbe() {
            const probeGeo = new THREE.SphereGeometry(0.05, 16, 8);
            const probeMat = new THREE.MeshStandardMaterial({color: 0xcccccc, metalness: 0.8, roughness: 0.2});
            const probeMesh = new THREE.Mesh(probeGeo, probeMat);
            probeMesh.userData = { launched: false, trajectoryPoints: [] };
            
            const trajectoryLine = new THREE.Line(
                new THREE.BufferGeometry(),
                new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 })
            );
            
            const probe = { mesh: probeMesh, velocity: new THREE.Vector3(), trajectory: trajectoryLine };
            launchableProbes.push(probe);
            return probe;
        }

        // --- CONTROLLERS & INTERACTION ---
        
        function setupControllers() {
            handModelFactory = new XRHandModelFactory();
            controllerModelFactory = new XRControllerModelFactory();

            // Controller 1 (Left)
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            cockpit.add(controller1);

            const controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            cockpit.add(controllerGrip1);

            hand1 = renderer.xr.getHand(0);
            hand1.add(handModelFactory.createHandModel(hand1, 'mesh'));
            cockpit.add(hand1);

            // Controller 2 (Right)
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            cockpit.add(controller2);
            
            const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]);
            const laserLine = new THREE.Line(laserGeo, new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.7 }));
            controller2.add(laserLine);
            controller2.userData.laser = laserLine;

            const controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            cockpit.add(controllerGrip2);

            hand2 = renderer.xr.getHand(1);
            hand2.add(handModelFactory.createHandModel(hand2, 'mesh'));
            cockpit.add(hand2);
        }

        function onSelectStart(event) {
            const controller = event.target;
            const intersections = getIntersections(controller);

            if (intersections.length > 0) {
                const intersection = intersections[0];
                const object = intersection.object;
                
                if (object.userData.type === 'flightStick' || object.userData.type === 'throttle') {
                    grabbedObject = object;
                    controller.attach(object);
                    if (uiBeepSound) uiBeepSound.play();
                } else if (object.userData.type === 'nav_button') {
                    const targetBody = celestialBodies.find(b => b.data.name === object.userData.targetName);
                    if(targetBody) {
                        selectedTarget = targetBody;
                        warpTo(targetBody);
                    }
                } else if (object.userData.type === 'probe_launch_button') {
                    launchProbe();
                } else if (object.userData.type === 'tts_button') {
                     if (selectedTarget && selectedTarget.data.funFacts) {
                        const fact = selectedTarget.data.funFacts[Math.floor(Math.random() * selectedTarget.data.funFacts.length)];
                        narrate(fact);
                    }
                }
            }
        }
        
        function onSelectEnd(event) {
            if (grabbedObject) {
                const parent = grabbedObject.userData.type === 'throttle' 
                    ? cockpit.children.find(c => c.children.includes(grabbedObject)) 
                    : cockpit.children.find(c => c.children.find(gc => gc.children.includes(grabbedObject)));
                if(parent) parent.attach(grabbedObject);
                grabbedObject = null;
            }
        }

        function getIntersections(controller) {
            const tempMatrix = new THREE.Matrix4();
            tempMatrix.identity().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            return raycaster.intersectObjects([
                ...cockpit.children, 
                ...cockpit.children.flatMap(c => c.children),
                ...cockpit.children.flatMap(c => c.children.flatMap(gc => gc.children))
            ], true);
        }

        function handleController(controller) {
            if (grabbedObject) {
                const type = grabbedObject.userData.type;
                if(type === 'throttle') {
                    const localPos = grabbedObject.parent.worldToLocal(grabbedObject.position.clone());
                    grabbedObject.position.x = 0; // Constrain movement
                    grabbedObject.position.y = 0;
                    const { minZ, maxZ } = grabbedObject.userData;
                    grabbedObject.position.z = Math.max(minZ, Math.min(maxZ, localPos.z));

                    // Map position to speed (0 to 10)
                    flightSpeed = ((grabbedObject.position.z - minZ) / (maxZ - minZ)) * 50; // speed up to 50
                
                } else if(type === 'flightStick') {
                    const localPos = grabbedObject.parent.worldToLocal(grabbedObject.position.clone());
                    grabbedObject.position.set(localPos.x, localPos.y, 0); // Constrain z
                    grabbedObject.lookAt(new THREE.Vector3(localPos.x, localPos.y, 1));
                    
                    const pitch = -grabbedObject.rotation.x;
                    const yaw = grabbedObject.rotation.y;
                    cockpit.rotation.x = THREE.MathUtils.lerp(cockpit.rotation.x, cockpit.rotation.x - pitch * 0.1, 0.1);
                    cockpit.rotation.y = THREE.MathUtils.lerp(cockpit.rotation.y, cockpit.rotation.y - yaw * 0.1, 0.1);
                }
                
            } else if (controller === controller2) { // Right controller for pointing
                const intersections = getIntersections(controller);
                const laser = controller.userData.laser;
                if (intersections.length > 0) {
                    laser.scale.z = intersections[0].distance;
                    const obj = intersections[0].object;
                    if (obj.userData.isButton) {
                        // Highlight button logic can go here
                    }
                } else {
                    laser.scale.z = 5;
                }
            }
        }

        // --- UI & NARRATION ---

        function updateUIPanels() {
            // Navigation Panel
            const navCtx = navPanel.userData.context;
            drawPanelBackground(navCtx, 'NAV / WARP');
            solarSystemData.forEach((body, i) => {
                const yPos = 80 + i * 30;
                const buttonData = {x: 50, y: yPos - 20, w: 412, h: 25, targetName: body.name };
                drawButton(navCtx, body.name, buttonData, selectedTarget?.data.name === body.name);
                navPanel.userData[body.name] = buttonData;
            });
            navPanel.userData.texture.needsUpdate = true;
            
            // Info Panel
            const infoCtx = infoPanel.userData.context;
            drawPanelBackground(infoCtx, 'SYSTEM INFO');
            if (selectedTarget) {
                const data = selectedTarget.data;
                infoCtx.fillStyle = 'white';
                infoCtx.font = '24px sans-serif';
                infoCtx.fillText(`Target: ${data.name}`, 30, 80);
                infoCtx.font = '20px sans-serif';
                infoCtx.fillText(`Radius: ${data.radius.toLocaleString()} km`, 30, 120);
                if(data.a) infoCtx.fillText(`Orbit (a): ${data.a.toLocaleString()}M km`, 30, 150);
                if(data.distAU) infoCtx.fillText(`Distance: ${data.distAU} AU`, 30, 120);
                
                const ttsButtonData = {x: 50, y: 280, w: 412, h: 40, type: 'tts_button' };
                drawButton(infoCtx, "NARRATE FUN FACT", ttsButtonData, false);
                infoPanel.userData['tts_button'] = ttsButtonData;

            } else {
                infoCtx.fillStyle = '#aaa';
                infoCtx.font = '24px sans-serif';
                infoCtx.fillText('No target selected.', 30, 80);
            }
            infoPanel.userData.texture.needsUpdate = true;

            // Probe Panel
            const probeCtx = probePanel.userData.context;
            drawPanelBackground(probeCtx, 'PROBE CONTROL');
            probeCtx.fillStyle = 'white';
            probeCtx.font = '20px sans-serif';
            probeCtx.fillText(`Active Probe: ${activeProbe ? 'Yes' : 'No'}`, 30, 80);
            if (activeProbe) {
                const speed = activeProbe.velocity.length() / BODY_SCALE;
                probeCtx.fillText(`Velocity: ${speed.toFixed(2)} km/s`, 30, 110);
            }
            const launchButtonData = {x: 50, y: 280, w: 412, h: 40, type: 'probe_launch_button'};
            drawButton(probeCtx, "LAUNCH PROBE", launchButtonData, false);
            probePanel.userData['probe_launch_button'] = launchButtonData;
            probePanel.userData.texture.needsUpdate = true;
        }

        function drawPanelBackground(ctx, title) {
            ctx.fillStyle = '#0a1a2a';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 32px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(title, ctx.canvas.width / 2, 40);
            ctx.textAlign = 'left';
        }
        
        function drawButton(ctx, text, data, isActive) {
            ctx.fillStyle = isActive ? '#ffff00' : '#00ffff';
            ctx.font = '22px sans-serif';
            ctx.fillText(text, data.x + 10, data.y + 18);
            ctx.strokeStyle = isActive ? '#ffff00' : '#00ffff';
            ctx.strokeRect(data.x, data.y, data.w, data.h);
        }
        
        function narrate(text) {
            if (!window.speechSynthesis) return;
            const utterance = new SpeechSynthesisUtterance(text);
            speechSynthesis.speak(utterance);
        }

        // --- CORE LOGIC & PHYSICS ---

        function launchProbe() {
            const probe = createLaunchableProbe();
            
            // Launch from in front of the cockpit
            const launchPos = new THREE.Vector3(0, 1.6, -5);
            cockpit.localToWorld(launchPos);
            probe.mesh.position.copy(launchPos);
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            probe.velocity = direction.multiplyScalar(2000 * BODY_SCALE); // 2000 km/s initial velocity
            probe.launched = true;
            
            solarGroup.add(probe.mesh);
            solarGroup.add(probe.trajectory);
            
            activeProbe = probe;
            gravityArrow.visible = true;
            if (launchSound) launchSound.play();
        }

        function updatePhysics(delta) {
            // Update planet/moon orbits
            celestialBodies.forEach(body => {
                const data = body.data;
                if (!data.period) return;
                
                const n = (2 * Math.PI) / (data.period * 24 * 3600); // Mean motion
                body.currentMeanAnomaly += n * delta * 5e5; // Time acceleration

                let pos;
                if(body.isMoon){
                    const parentRadius = body.parentBody.data.radius * BODY_SCALE * 10;
                    const a_km = data.a * 1e6;
                    const a = parentRadius + (a_km * BODY_SCALE * 100);
                    pos = getEllipsePosition(a, data.e, body.currentMeanAnomaly);
                } else {
                    const a = data.a * 1e6 * BODY_SCALE;
                    pos = getEllipsePosition(a, data.e, body.currentMeanAnomaly);
                }
                body.mesh.position.set(pos.x, 0, pos.z);

                // Axial rotation
                const rotationSpeed = (2 * Math.PI) / (data.period / 365.25); // Relative to earth year
                body.mesh.rotation.y += rotationSpeed * delta * 50;
                if(body.clouds) body.clouds.rotation.y += rotationSpeed * delta * 60;
            });
            
            // Update Sun shader
            const sun = celestialBodies.find(b => b.isSun);
            if(sun) sun.mesh.material.uniforms.time.value += delta;
            
            // Update launchable probe physics (N-body)
            launchableProbes.forEach(probe => {
                if (!probe.launched) return;

                const netAcceleration = new THREE.Vector3();
                celestialBodies.forEach(body => {
                    if (!body.data.mass) return;
                    
                    const rVec = new THREE.Vector3().subVectors(body.mesh.getWorldPosition(new THREE.Vector3()), probe.mesh.position);
                    const rSq = rVec.lengthSq();
                    if (rSq < 1) return; // Avoid division by zero
                    
                    const forceMag = (G * body.data.mass) / rSq; // a = F/m, probe mass cancels out
                    netAcceleration.add(rVec.normalize().multiplyScalar(forceMag));
                });
                
                probe.velocity.add(netAcceleration.multiplyScalar(delta));
                probe.mesh.position.add(probe.velocity.clone().multiplyScalar(delta));

                // Update trajectory line
                probe.mesh.userData.trajectoryPoints.push(probe.mesh.position.clone());
                if (probe.mesh.userData.trajectoryPoints.length > 500) {
                    probe.mesh.userData.trajectoryPoints.shift();
                }
                probe.trajectory.geometry.setFromPoints(probe.mesh.userData.trajectoryPoints);
                
                // Update gravity arrow
                if (probe === activeProbe) {
                    const dir = netAcceleration.clone().normalize();
                    const len = Math.min(1.5, 0.2 + netAcceleration.length() * 1e12); // Scale for visibility
                    gravityArrow.setDirection(dir);
                    gravityArrow.setLength(len);
                }
            });

            // Update ship flight
            if (flightSpeed > 0) {
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(cockpit.quaternion);
                solarGroup.position.add(direction.multiplyScalar(-flightSpeed * delta));
            }
        }
        
        function getEllipsePosition(a, e, M) {
            // Solve Kepler's equation M = E - e*sin(E) for E (Eccentric Anomaly) using Newton's method
            let E = M;
            for (let i = 0; i < 5; i++) { // 5 iterations is usually enough
                E = E - (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
            }
            const x = a * (Math.cos(E) - e);
            const z = a * Math.sqrt(1 - e * e) * Math.sin(E);
            return new THREE.Vector3(x, 0, z);
        }
        
        function warpTo(destination) {
            if (warpSound && !warpSound.isPlaying) warpSound.play();
            const startPos = solarGroup.position.clone();
            const endPos = destination.mesh.getWorldPosition(new THREE.Vector3()).negate();
            
            const overlay = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 })
            );
            overlay.position.z = -0.1;
            camera.add(overlay);

            new TWEEN.Tween(overlay.material).to({ opacity: 1.0 }, 500).yoyo(true).repeat(1)
                .onUpdate( (obj, elapsed) => {
                    if (elapsed > 0.5) { // At the halfway point, snap position
                        solarGroup.position.copy(endPos);
                    }
                })
                .onComplete(() => {
                    camera.remove(overlay);
                })
                .start();
        }

        // --- RENDER LOOP ---
        function animate() {
            const delta = clock.getDelta();

            handleController(controller1);
            handleController(controller2);
            
            updatePhysics(delta);
            updateUIPanels();

            TWEEN.update();
            renderer.render(scene, camera);
        }

        // --- START ---
        init();
    </script>
</body>
</html>
