<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Explorer VR</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        canvas { display: block; }
        #vr-button { position: absolute; bottom: 20px; right: 20px; z-index: 1000; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<script type="module">
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

// --- GLOBALS & CONSTANTS ---
let scene, camera, renderer, clock;
let solarGroup, cockpit;
let listener, ambientSound, warpSound, uiBeepSound, launchSound;
const textureLoader = new THREE.TextureLoader();

let controller1, controller2;
let hand1, hand2;
let handModelFactory, controllerModelFactory;
const raycaster = new THREE.Raycaster();
let grabbedObject = null;
let grabbingController = null;
let grabOffset = new THREE.Vector3(); // For direct manipulation
let selectedTarget = null;
let activeProbe = null;

let flightSpeed = 0;
const celestialBodies = [];
const launchableProbes = [];

// Runtime parameters that can be adjusted via in‑game sliders.
let distanceMultiplier = 1;
let timeScale         = 1;

// Fundamental constants
const G = 6.67430e-11;               // Gravitational constant
const KM_IN_AU = 149.6e6;            // Number of km in one AU
const UNIVERSE_SCALE = 100;          // 1 AU = 100 world units
const BODY_SCALE    = UNIVERSE_SCALE / KM_IN_AU; // km → world units conversion
const SIZE_MULTIPLIER = 1;           // Use a multiplier of one to preserve correct relative sizes

// Panels & helpers
let mainPanel, gravityArrow;

// Timestamp of the last hand interaction to avoid accidental rapid triggers.
let lastHandPressTime = 0;

// Data definitions for planets, moons, probes etc. (No changes here)
const solarSystemData = [
    { name: 'Sun', radius: 696340, color: 0xfff000, funFacts: [
        "The Sun contains more than 99.8% of the mass of the solar system.",
        "Its diameter is about 109 times that of Earth.",
        "The core is over 27 million degrees Fahrenheit while the surface is about 10,000 °F.",
        "It formed around 4.6 billion years ago and will expand into a red giant in roughly five billion years.",
        "Its gravitational pull keeps all planets, asteroids and comets bound in their orbits."
    ] },
    { name: 'Mercury', radius: 2440, color: 0x9f9f9f, a: 57.9, e: 0.205, period: 88, inclination: 7.0, axialTilt: 0.03, lonAscNode: 48.3, argPeri: 29.1, meanAnomalyEpoch: 174.7, funFacts: [
        "Mercury is the smallest and closest planet to the Sun.",
        "A single day on Mercury (sunrise to sunrise) lasts 176 Earth days while a year is 88 days.",
        "It is the second‑densest planet after Earth despite its small size.",
        "Mercury has a global magnetic field about one percent as strong as Earth’s.",
        "Temperatures swing from 427 °C in sunlight to –173 °C in darkness, yet water ice exists in permanently shadowed craters at its poles."
    ] },
    { name: 'Venus', radius: 6052, color: 0xdab36d, a: 108.2, e: 0.007, period: 224.7, inclination: 3.4, axialTilt: 177.4, lonAscNode: 76.7, argPeri: 54.9, meanAnomalyEpoch: 50.1, funFacts: [
        "A day on Venus (243 Earth days) is longer than its 225‑day year.",
        "It rotates backwards (retrograde) compared to most planets.",
        "It is the hottest planet in the solar system at roughly 465 °C due to a runaway greenhouse effect.",
        "Surface pressure on Venus is more than 90 times Earth’s atmospheric pressure.",
        "Often called Earth’s sister planet because of its similar size and mass."
    ] },
    { name: 'Earth', radius: 6371, color: 0x4f70a3, a: 149.6, e: 0.017, period: 365.2, inclination: 0.0, axialTilt: 23.4, lonAscNode: -11.2, argPeri: 114.2, meanAnomalyEpoch: 358.6, funFacts: [
        "Earth is the only planet not named after a mythological deity.",
        "It is the densest planet in the solar system.",
        "Earth’s rotation is gradually slowing by about 17 milliseconds per century.",
        "Roughly 70 percent of its surface is covered by water.",
        "Its magnetic field shields the surface from harmful solar wind and cosmic radiation."
    ], moons: [
        { name: 'Moon', radius: 1737, color: 0xcccccc, a: 0.384, e: 0.055, period: 27.3, inclination: 5.1, lonAscNode: 125.08, argPeri: 318.15, meanAnomalyEpoch: 115.36, funFacts: [
            "The Moon is drifting away from Earth by about 3.8 cm per year.",
            "It is the 5th largest moon in the solar system.",
            "The Moon has 'moonquakes' caused by the Earth's gravitational pull."
        ] }
    ]},
    { name: 'Mars', radius: 3390, color: 0xc1440e, a: 227.9, e: 0.094, period: 687, inclination: 1.8, axialTilt: 25.2, lonAscNode: 49.6, argPeri: 286.5, meanAnomalyEpoch: 19.4, funFacts: [
        "Home to Olympus Mons, the tallest volcano and mountain in the solar system.",
        "Its red colour comes from iron oxide (rust) in the soil and rocks.",
        "Mars has the largest dust storms in the solar system, sometimes covering the entire planet.",
        "The atmosphere is less than one percent as dense as Earth’s and composed mostly of carbon dioxide.",
        "Evidence suggests Mars once had flowing liquid water and perhaps conditions suitable for life."
    ], moons: [
        { name: 'Phobos', radius: 11.2, color: 0x8f8f8f, a: 0.00937, e: 0.015, period: 0.3, inclination: 1.1, funFacts: ["Phobos is getting closer to Mars and will either crash into it or break up into a ring in about 50 million years.", "It is a 'captured' asteroid, not a naturally formed moon."]},
        { name: 'Deimos', radius: 6.2, color: 0xafafaf, a: 0.0234, e: 0.0002, period: 1.26, inclination: 0.9, funFacts: ["Deimos is one of the smallest known moons in the solar system.", "It is covered in a thick layer of fine dust, or regolith."]}
    ]},
    { name: 'Jupiter', radius: 69911, color: 0xc8ab89, a: 778.6, e: 0.049, period: 4331, inclination: 1.3, axialTilt: 3.1, lonAscNode: 100.5, argPeri: 273.8, meanAnomalyEpoch: 20.0, funFacts: [
        "Jupiter is the largest planet—more than twice as massive as all the other planets combined.",
        "The Great Red Spot is a colossal storm that has raged for centuries.",
        "It has the shortest day of any planet, rotating once every 10 hours.",
        "Jupiter has at least 79 moons; its largest moon, Ganymede, is bigger than the planet Mercury.",
        "The planet’s magnetic field is the strongest of any planet in the solar system."
    ], moons: [
        { name: 'Io', radius: 1821, color: 0xf3d649, a: 0.421, e: 0.004, period: 1.77, inclination: 0.05, funFacts: ["Io is the most volcanically active body in the solar system, with hundreds of volcanoes.", "Its surface is covered in sulfur in various colorful forms."]},
        { name: 'Europa', radius: 1560, color: 0x8f7f70, a: 0.671, e: 0.009, period: 3.55, inclination: 0.47, funFacts: ["Europa's icy surface may hide a global saltwater ocean underneath.", "Scientists believe this ocean could potentially harbor extraterrestrial life."]},
        { name: 'Ganymede', radius: 2634, color: 0x9e9990, a: 1.070, e: 0.001, period: 7.15, inclination: 0.20, funFacts: ["Ganymede is the largest moon in the solar system, bigger than the planet Mercury.", "It is the only moon known to have its own magnetic field."]},
        { name: 'Callisto', radius: 2410, color: 0x5a5651, a: 1.882, e: 0.007, period: 16.69, inclination: 0.20, funFacts: ["Callisto has the most heavily cratered surface of any object in the solar system.", "It is thought to have a 'dead' surface that hasn't changed much in 4 billion years."]}
    ]},
    { name: 'Saturn', radius: 58232, color: 0xe3d9b1, a: 1433.5, e: 0.057, period: 10747, inclination: 2.5, axialTilt: 26.7, lonAscNode: 113.7, argPeri: 339.3, meanAnomalyEpoch: 317.0, funFacts: [
        "Saturn’s rings are made of billions of particles of ice and rock and are only about 10 metres thick on average.",
        "The planet is less dense than water and would float in a bathtub large enough to hold it.",
        "Winds on Saturn can reach speeds of around 1,800 kilometres per hour.",
        "A persistent hexagonal storm rages at Saturn’s north pole.",
        "It has more than 145 known moons; Titan, the largest, has a thick nitrogen‑rich atmosphere."
    ], moons: [
        { name: 'Titan', radius: 2575, color: 0xf5ad6f, a: 1.221, e: 0.029, period: 15.9, inclination: 0.33, funFacts: ["Titan is the only moon with a thick, dense atmosphere.", "It has rivers, lakes, and seas of liquid methane and ethane on its surface."]}
    ]},
    { name: 'Uranus', radius: 25362, color: 0xafdbd3, a: 2872.5, e: 0.046, period: 30589, inclination: 0.8, axialTilt: 97.8, lonAscNode: 74.0, argPeri: 98.9, meanAnomalyEpoch: 142.2, funFacts: [
        "Uranus is tilted on its side by about 98°, likely the result of a giant impact in its distant past.",
        "Its seasons each last more than 20 Earth years because it takes 84 years to orbit the Sun.",
        "It is the coldest planet in the solar system, with temperatures dropping below −200 °C.",
        "Discovered by William Herschel in 1781, it was the first planet found with a telescope.",
        "It has faint dark rings and moons named after characters from Shakespeare and Alexander Pope."
    ], moons: [
        { name: 'Miranda', radius: 236, color: 0xc0c0c0, a: 0.129, e: 0.001, period: 1.4, inclination: 4.2, funFacts: ["Miranda has one of the most bizarre and varied landscapes in the solar system.", "It features enormous canyons, terraced layers, and a patchwork of different surfaces."]}
    ]},
    { name: 'Neptune', radius: 24622, color: 0x3d5a9c, a: 4495.1, e: 0.011, period: 59800, inclination: 1.8, axialTilt: 28.3, lonAscNode: 131.8, argPeri: 276.3, meanAnomalyEpoch: 256.2, funFacts: [
        "Neptune was predicted by mathematicians before it was observed through a telescope.",
        "It has the strongest winds in the solar system, topping 2,100 kilometres per hour.",
        "A Neptunian year lasts nearly 165 Earth years.",
        "Neptune radiates more heat than it receives from the Sun.",
        "Its largest moon, Triton, has nitrogen geysers and orbits the planet retrograde to its rotation."
    ], moons: [
        { name: 'Triton', radius: 1353, color: 0xced4da, a: 0.354, e: 0.0, period: -5.9, inclination: 157, funFacts: ["Triton is the only large moon in the solar system that orbits in the opposite direction of its planet's rotation (retrograde orbit).", "It has geysers that erupt nitrogen frost and is one of the coldest objects in the solar system."]}
    ]},
    { name: 'Pluto', type: 'Dwarf Planet', radius: 1188, color: 0xead9c2, a: 5906.4, e: 0.249, period: 90560, inclination: 17.2, axialTilt: 122.5, lonAscNode: 110.3, argPeri: 113.8, meanAnomalyEpoch: 14.5, funFacts: [
        "Its orbit is so eccentric it's sometimes closer to the Sun than Neptune.",
        "Features a massive, heart-shaped nitrogen glacier named Tombaugh Regio.",
        "Its largest moon, Charon, is so big they orbit a common point in space outside of Pluto."
    ], moons: [
        { name: 'Charon', radius: 606, color: 0xb5a99d, a: 0.0195, e: 0.0, period: 6.4, inclination: 0.00, funFacts: ["Charon is so large relative to Pluto (about half its diameter) that they are considered a binary system.", "It has a reddish north pole, thought to be caused by gases escaping from Pluto's atmosphere and freezing on Charon's surface."]}
    ]},
    { name: "Halley's Comet", type: 'Comet', radius: 5.5, color: 0xffffff, a: 2667, e: 0.967, period: 27740, inclination: 162.2, axialTilt: 0, lonAscNode: 58.4, argPeri: 111.3, meanAnomalyEpoch: 351.4, funFacts: [
        "The most famous comet, visible from Earth every 75-76 years.",
        "It is a 'periodic' comet and will next appear in mid-2061.",
        "Its tail always points away from the Sun due to solar wind."
    ] }
];
const probesData = [
    { name: 'Voyager 1', distAU: 167.3, declination: 12.1, rightAscension: 267.0, funFacts: ["Launched in 1977, it is the most distant human-made object from Earth.", "It entered interstellar space in 2012.", "Carries a 'Golden Record' with sounds and images of Earth."]},
    { name: 'Voyager 2', distAU: 139.3, declination: -55.5, rightAscension: 299.1, funFacts: ["The only spacecraft to have visited all four gas giants: Jupiter, Saturn, Uranus, and Neptune.", "It discovered 11 new moons around Uranus and 6 around Neptune.", "Entered interstellar space in 2018."]},
    { name: 'Pioneer 10', distAU: 139.0, declination: 25.6, rightAscension: 75.8, funFacts: ["The first spacecraft to traverse the asteroid belt and make direct observations of Jupiter.", "Its last signal was received in 2003 and it is now silent.", "Carries a plaque with a pictorial message from humankind."]},
    { name: 'New Horizons', distAU: 60.5, declination: -21.4, rightAscension: 290.0, funFacts: ["Performed the first-ever flyby of the Pluto system in 2015.", "Visited the Kuiper Belt Object 'Arrokoth' in 2019, the most distant object ever explored up close.", "Travels at over 58,000 km/h."]}
];


// --- INITIALIZATION ---
function init() {
    scene = new THREE.Scene();
    clock = new THREE.Clock();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5e8);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    listener = new THREE.AudioListener();
    camera.add(listener);

    solarGroup = new THREE.Group();
    scene.add(solarGroup);
    
    // The cockpit is a group containing all ship components.
    cockpit = new THREE.Group();
    // CRITICAL FIX: Rotate the entire cockpit to face the player's starting direction.
    cockpit.rotation.y = Math.PI;
    scene.add(cockpit);
    
    camera.position.set(0, 1.6, 0);

    const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
    scene.add(ambientLight);

    createStarfield();
    createSolarSystem();
    createDeepSpaceProbes();
    createCockpit();
    setupControllers();
    loadAudio();

    solarGroup.position.set(0, 0, -200);

    window.addEventListener('resize', onWindowResize);
    renderer.setAnimationLoop(animate);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// --- AUDIO ---
function loadAudio() {
    const audioLoader = new THREE.AudioLoader();
    audioLoader.load('sounds/ambience.mp3', b => { (ambientSound = new THREE.Audio(listener)).setBuffer(b).setLoop(true).setVolume(0.2).play(); });
    audioLoader.load('sounds/warp.mp3', b => { (warpSound = new THREE.Audio(listener)).setBuffer(b).setVolume(0.8); });
    audioLoader.load('sounds/beep.mp3', b => { (uiBeepSound = new THREE.Audio(listener)).setBuffer(b).setVolume(0.4); });
    // Sound file `launch.mp3` does not exist in the provided file list.
    // audioLoader.load('sounds/launch.mp3', b => { (launchSound = new THREE.Audio(listener)).setBuffer(b).setVolume(0.6); });
}

// --- SCENE CREATION ---
function createStarfield() {
    const createStars = (count, size, range) => {
        const verts = [];
        for (let i = 0; i < count; i++) {
            verts.push(THREE.MathUtils.randFloatSpread(range), THREE.MathUtils.randFloatSpread(range), THREE.MathUtils.randFloatSpread(range));
        }
        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
        const mat = new THREE.PointsMaterial({ color: 0xaaaaaa, size: size, sizeAttenuation: false });
        solarGroup.add(new THREE.Points(geo, mat));
    };
    createStars(15000, 2.5, 20000);
    createStars(1000, 5, 15000);
}

function createSolarSystem() {
    const sunData = solarSystemData.find(d => d.name === 'Sun');
    const sunGeo = new THREE.SphereGeometry(sunData.radius * BODY_SCALE * SIZE_MULTIPLIER, 64, 32);
    const sunMat = new THREE.MeshBasicMaterial({ color: sunData.color });
    const sunMesh = new THREE.Mesh(sunGeo, sunMat);
    sunMesh.add(new THREE.PointLight(0xffffff, 3.5, 0, 0));
    celestialBodies.push({ mesh: sunMesh, data: sunData, isSun: true });
    solarGroup.add(sunMesh);

    solarSystemData.forEach(bodyData => {
        if (bodyData.isSun) return;
        const planetGeo = new THREE.SphereGeometry(bodyData.radius * BODY_SCALE * SIZE_MULTIPLIER, 48, 24);
        const planetMat = new THREE.MeshStandardMaterial({ color: bodyData.color });
        const planetMesh = new THREE.Mesh(planetGeo, planetMat);
        const planetObj = { mesh: planetMesh, data: bodyData, isMoon: false };
        celestialBodies.push(planetObj);
        solarGroup.add(planetMesh);

        if (bodyData.moons) {
            bodyData.moons.forEach(moonData => {
                const moonGeo = new THREE.SphereGeometry(moonData.radius * BODY_SCALE * SIZE_MULTIPLIER * 0.5, 32, 16);
                const moonMat = new THREE.MeshStandardMaterial({ color: moonData.color });
                const moonMesh = new THREE.Mesh(moonGeo, moonMat);
                const moonObj = { mesh: moonMesh, data: moonData, isMoon: true, parentBody: planetObj };
                celestialBodies.push(moonObj);
                solarGroup.add(moonMesh);
            });
        }
    });
}

function createDeepSpaceProbes() {
    probesData.forEach(probe => {
        const probeGeo = new THREE.SphereGeometry(0.02, 6, 6);
        const probeMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const probeMesh = new THREE.Mesh(probeGeo, probeMat);
        const r = probe.distAU * UNIVERSE_SCALE;
        const raRad  = THREE.MathUtils.degToRad(probe.rightAscension);
        const decRad = THREE.MathUtils.degToRad(probe.declination);
        probeMesh.position.set(r * Math.cos(decRad) * Math.cos(raRad), r * Math.sin(decRad), r * Math.cos(decRad) * Math.sin(raRad));
        probeMesh.userData = { type: 'probe', data: probe };
        solarGroup.add(probeMesh);
    });
}

// --- COCKPIT CREATION (Redesigned) ---
function createCockpit() {
    // Floor
    const floorGeo = new THREE.CircleGeometry(1.8, 40);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.2, roughness: 0.6, side: THREE.DoubleSide });
    const floorMesh = new THREE.Mesh(floorGeo, floorMat);
    floorMesh.rotation.x = -Math.PI / 2;
    cockpit.add(floorMesh);

    // NEW: Diamond-shaped wireframe canopy
    const canopyGeo = new THREE.IcosahedronGeometry(4, 0);
    const canopyMat = new THREE.MeshStandardMaterial({ color: 0x6699ff, emissive: 0x224488, wireframe: true, transparent: true, opacity: 0.3 });
    const canopy = new THREE.Mesh(canopyGeo, canopyMat);
    canopy.position.y = 1.8; // Position it so player is in the center
    canopy.scale.set(1, 1.2, 1); // Elongate it vertically
    cockpit.add(canopy);

    // Main console
    const consoleGroup = new THREE.Group();
    const consoleMat = new THREE.MeshStandardMaterial({ color: 0x1c2129, metalness: 0.7, roughness: 0.3 });
    const consoleShape = new THREE.Shape()
        .moveTo(-1.2, 0)
        .absarc(0, 0, 1.2, Math.PI, Math.PI * 2, false)
        .absarc(0, 0, 0.8, Math.PI * 2, Math.PI, true)
        .closePath();
    const consoleGeo = new THREE.ExtrudeGeometry(consoleShape, { depth: 0.1, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02, bevelSegments: 2 });
    const consoleMesh = new THREE.Mesh(consoleGeo, consoleMat);
    consoleMesh.rotation.x = -Math.PI / 2;
    consoleMesh.position.set(0, 1.0, 0.7);
    consoleGroup.add(consoleMesh);
    cockpit.add(consoleGroup);

    // Curved UI Panel
    const panelRadius = 0.99, panelHeight = 0.6, panelAngle = Math.PI * 0.9;
    const panelGeo = new THREE.CylinderGeometry(panelRadius, panelRadius, panelHeight, 64, 1, true, -panelAngle / 2, panelAngle);
    const panelMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.95 });
    mainPanel = new THREE.Mesh(panelGeo, panelMaterial);
    mainPanel.position.set(0, 1.15, 0.7);
    mainPanel.userData.type = 'mainPanel';
    mainPanel.userData.canvas = document.createElement('canvas');
    mainPanel.userData.canvas.width = 1024;
    mainPanel.userData.canvas.height = Math.round(1024 * (panelHeight / (panelRadius * panelAngle)));
    mainPanel.userData.context = mainPanel.userData.canvas.getContext('2d');
    mainPanel.userData.texture = new THREE.CanvasTexture(mainPanel.userData.canvas);
    mainPanel.material.map = mainPanel.userData.texture;
    cockpit.add(mainPanel);

    // NEW: Central control pod
    const controlPodGeo = new THREE.BoxGeometry(0.7, 0.1, 0.4);
    const controlPodMat = new THREE.MeshStandardMaterial({ color: 0x111, metalness: 0.8, roughness: 0.4 });
    const controlPod = new THREE.Mesh(controlPodGeo, controlPodMat);
    controlPod.position.set(0, 1.0, 0.4);
    cockpit.add(controlPod);
    
    // Throttle on left side of pod
    const throttleBase = new THREE.Group();
    throttleBase.position.set(-0.2, 0.05, 0);
    controlPod.add(throttleBase);
    const throttleLeverGeo = new THREE.BoxGeometry(0.12, 0.2, 0.06);
    const throttleLeverMat = new THREE.MeshStandardMaterial({ color: 0x33aa33, emissive: 0x002200, metalness: 0.4, roughness: 0.3 });
    const throttleLever = new THREE.Mesh(throttleLeverGeo, throttleLeverMat);
    throttleLever.position.y = 0.1;
    throttleLever.userData = { type: 'throttle', minZ: -0.15, maxZ: 0.15 };
    throttleBase.add(throttleLever);

    // Flight Stick on right side of pod
    const stickBase = new THREE.Group();
    stickBase.position.set(0.2, 0.05, 0);
    controlPod.add(stickBase);
    const flightStickGeo = new THREE.CylinderGeometry(0.02, 0.04, 0.3, 12);
    const flightStickMat = new THREE.MeshStandardMaterial({ color: 0xaa3333, emissive: 0x220000, metalness: 0.4, roughness: 0.3 });
    const flightStick = new THREE.Mesh(flightStickGeo, flightStickMat);
    flightStick.position.y = 0.15;
    flightStick.userData = { type: 'flightStick', baseRotation: new THREE.Quaternion() };
    stickBase.add(flightStick);
}

function createLaunchableProbe() {
    // Probe creation logic (unchanged)
}

// --- CONTROLLERS & INTERACTION (Overhauled) ---
function setupControllers() {
    handModelFactory = new XRHandModelFactory();

    function onControllerConnected(event) {
        const controller = event.target;
        controller.addEventListener('selectstart', onSelectStart);
        controller.addEventListener('selectend', onSelectEnd);
        cockpit.add(controller);

        if (controller.hand) {
            // Add animated hand model
            controller.hand.add(handModelFactory.createHandModel(controller.hand));
        }
    }
    
    controller1 = renderer.xr.getController(0);
    controller1.addEventListener('connected', onControllerConnected);
    
    controller2 = renderer.xr.getController(1);
    controller2.addEventListener('connected', onControllerConnected);
}

function onSelectStart(event) {
    const controller = event.target;
    triggerHapticFeedback(controller, 0.7, 50);

    const intersections = getIntersections(controller);
    if (intersections.length > 0) {
        const intersection = intersections[0];
        const obj = intersection.object;

        // Try to grab a flight control
        if (obj.userData.type === 'flightStick' || obj.userData.type === 'throttle') {
            grabbedObject = obj;
            grabbingController = controller;
            
            // Calculate offset for direct manipulation
            const worldControllerPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
            const worldObjectPos = new THREE.Vector3().setFromMatrixPosition(obj.matrixWorld);
            grabOffset.subVectors(worldObjectPos, worldControllerPos);

            if (uiBeepSound) uiBeepSound.play();
            return;
        }

        // Interact with the UI panel using raycast
        if (obj === mainPanel && intersection.uv) {
            const px = intersection.uv.x * mainPanel.userData.canvas.width;
            const py = (1 - intersection.uv.y) * mainPanel.userData.canvas.height;
            if (handleUIPress(px, py)) {
                processUIActivation(controller);
            }
            return;
        }
        
        // Scan a celestial body
        const body = celestialBodies.find(b => b.mesh === obj);
        if (body) {
            selectedTarget = body;
            if (uiBeepSound) uiBeepSound.play();
        }
    }
}

function onSelectEnd(event) {
    if (grabbedObject) {
        // Reset flight stick rotation when released
        if (grabbedObject.userData.type === 'flightStick') {
            grabbedObject.quaternion.copy(grabbedObject.userData.baseRotation);
        }
        grabbedObject = null;
        grabbingController = null;
    }
}

function getIntersections(controller) {
    const tempMatrix = new THREE.Matrix4().identity().extractRotation(controller.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    return raycaster.intersectObjects(cockpit.children, true);
}

function handleControls(delta) {
    if (grabbedObject && grabbingController) {
        const controller = grabbingController;
        const targetWorldPos = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld).add(grabOffset);
        const targetLocalPos = grabbedObject.parent.worldToLocal(targetWorldPos);

        if (grabbedObject.userData.type === 'throttle') {
            const { minZ, maxZ } = grabbedObject.userData;
            // Clamp movement to the Z axis of its base
            grabbedObject.position.z = Math.max(minZ, Math.min(maxZ, targetLocalPos.z));
            grabbedObject.position.x = 0;
            grabbedObject.position.y = 0.1;
            
            // Map throttle position to flight speed
            flightSpeed = ((grabbedObject.position.z - minZ) / (maxZ - minZ)) * 20;
        } else if (grabbedObject.userData.type === 'flightStick') {
            // Apply position to stick, but clamp to a radius
            targetLocalPos.z = 0; // Stick pivots at its base
            targetLocalPos.clampLength(0, 0.15); // Clamp movement radius
            grabbedObject.position.copy(targetLocalPos);

            // Calculate rotation based on stick position
            const targetLookAt = new THREE.Vector3(targetLocalPos.x, targetLocalPos.y, 1);
            grabbedObject.lookAt(targetLookAt);
            
            // Apply rotation to the cockpit
            const pitch = -grabbedObject.rotation.x;
            const yaw   = grabbedObject.rotation.y;
            const targetPitch = cockpit.rotation.x + pitch * 0.07;
            const targetYaw   = cockpit.rotation.y + yaw   * 0.07;
            cockpit.rotation.x = THREE.MathUtils.lerp(cockpit.rotation.x, targetPitch, 0.1);
            cockpit.rotation.y = THREE.MathUtils.lerp(cockpit.rotation.y, targetYaw,   0.1);
        }
    }

    // Apply ship flight motion from throttle
    if (flightSpeed > 0) {
        const direction = new THREE.Vector3(0, 0, 1); // Cockpit is rotated, so forward is now +Z
        direction.applyQuaternion(cockpit.quaternion);
        solarGroup.position.add(direction.multiplyScalar(-flightSpeed * delta));
    }
}


// --- HAND & UI HELPERS ---
function handleHandInteractions(hand) {
    if (!hand || !mainPanel || !hand.joints) return;
    const tip = hand.joints['index-finger-tip'];
    if (!tip) return;
    
    const now = clock.getElapsedTime();
    if (now - lastHandPressTime < 0.4) return;

    const tipWorld = new THREE.Vector3().setFromMatrixPosition(tip.matrixWorld);
    const panelInverse = new THREE.Matrix4().copy(mainPanel.matrixWorld).invert();
    const tipLocal = tipWorld.clone().applyMatrix4(panelInverse);
    
    const panelRadius = mainPanel.geometry.parameters.radiusTop;
    const panelHeight = mainPanel.geometry.parameters.height;
    const tipAngle = Math.atan2(-tipLocal.x, tipLocal.z);
    const panelAngle = mainPanel.geometry.parameters.thetaLength;
    const distFromSurface = Math.abs(Math.hypot(tipLocal.x, tipLocal.z) - panelRadius);
    
    if (distFromSurface < 0.03 && Math.abs(tipLocal.y) <= panelHeight / 2 && Math.abs(tipAngle) <= panelAngle / 2) {
        lastHandPressTime = now;
        const u = (tipAngle + panelAngle / 2) / panelAngle;
        const v = 1 - ((tipLocal.y + panelHeight / 2) / panelHeight);
        if (handleUIPress(u * mainPanel.userData.canvas.width, v * mainPanel.userData.canvas.height)) {
            processUIActivation(hand);
        }
    }
}

function handleUIPress(px, py) {
    // Check nav buttons
    if (mainPanel.userData.navButtons) {
        for (const btn of mainPanel.userData.navButtons) {
            if (px >= btn.x && px <= btn.x + btn.w && py >= btn.y && py <= btn.y + btn.h) {
                const targetBody = celestialBodies.find(b => b.data.name === btn.targetName);
                if (targetBody) { selectedTarget = targetBody; warpTo(targetBody); }
                return true;
            }
        }
    }
    // Check sliders
    const dist = mainPanel.userData.scaleSlider;
    if (dist && py >= dist.y && py <= dist.y + dist.h && px >= dist.x && px <= dist.x + dist.w) {
        distanceMultiplier = dist.min + ((px - dist.x) / dist.w) * (dist.max - dist.min);
        return true;
    }
    const tsl = mainPanel.userData.timeSlider;
    if (tsl && py >= tsl.y && py <= tsl.y + tsl.h && px >= tsl.x && px <= tsl.x + tsl.w) {
        timeScale = tsl.min + ((px - tsl.x) / tsl.w) * (tsl.max - tsl.min);
        return true;
    }
    // Check TTS button
    const tts = mainPanel.userData.tts_button;
    if (tts && px >= tts.x && px <= tts.x + tts.w && py >= tts.y && py <= tts.y + tts.h) {
        if (selectedTarget && selectedTarget.data.funFacts) {
            narrate(selectedTarget.data.funFacts[Math.floor(Math.random() * selectedTarget.data.funFacts.length)]);
        }
        return true;
    }
    return false;
}

function triggerHapticFeedback(controller, intensity = 0.5, duration = 50) {
    if (controller && controller.gamepad && controller.gamepad.hapticActuators && controller.gamepad.hapticActuators.length > 0) {
        controller.gamepad.hapticActuators[0].pulse(intensity, duration);
    }
}

function processUIActivation(source) {
    if (uiBeepSound) uiBeepSound.play();
    triggerHapticFeedback(source, 0.5, 20);
}

// --- UI DRAWING ---
function updateUIPanels() {
    if (!mainPanel) return;
    const ctx = mainPanel.userData.context;
    const { width, height } = ctx.canvas;
    
    ctx.fillStyle = '#0a1a2a';
    ctx.fillRect(0, 0, width, height);
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 3;
    ctx.strokeRect(0, 0, width, height);
    
    const sectionWidth = width / 3;
    ctx.strokeStyle = '#003040';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(sectionWidth, 50); ctx.lineTo(sectionWidth, height - 10);
    ctx.moveTo(sectionWidth * 2, 50); ctx.lineTo(sectionWidth * 2, height - 10);
    ctx.stroke();

    ctx.fillStyle = '#00ffff';
    ctx.font = 'bold 26px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('NAV / WARP', sectionWidth / 2, 40);
    ctx.fillText('SYSTEM INFO', sectionWidth + sectionWidth / 2, 40);
    ctx.fillText('PROBE CONTROL', sectionWidth * 2 + sectionWidth / 2, 40);
    
    // Nav section (two columns)
    mainPanel.userData.navButtons = [];
    const navBtnHeight = 18, navBtnVSpacing = 4, navYStart = 65;
    const navItemsPerCol = Math.ceil(solarSystemData.length / 2);
    const colWidth = (sectionWidth - 50) / 2;
    solarSystemData.forEach((body, i) => {
        const col = Math.floor(i / navItemsPerCol);
        const row = i % navItemsPerCol;
        const btn = {
            x: 20 + col * (colWidth + 10),
            y: navYStart + row * (navBtnHeight + navBtnVSpacing),
            w: colWidth, h: navBtnHeight, targetName: body.name
        };
        drawButton(ctx, body.name, btn, selectedTarget?.data.name === body.name, '16px sans-serif');
        mainPanel.userData.navButtons.push(btn);
    });

    // Info section
    const infoX = sectionWidth, infoMargin = 20;
    if (selectedTarget) {
        const data = selectedTarget.data;
        ctx.fillStyle = 'white';
        ctx.font = '22px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`${data.name}`, infoX + sectionWidth/2, 80);
        ctx.textAlign = 'left';
        ctx.font = '18px sans-serif';
        ctx.fillText(`Radius: ${data.radius.toLocaleString()} km`, infoX + infoMargin, 110);
        if (data.a) ctx.fillText(`Orbit: ${data.a.toLocaleString()} M km`, infoX + infoMargin, 130);
        if (data.distAU) ctx.fillText(`Dist: ${data.distAU} AU`, infoX + infoMargin, 130);
        const ttsBtn = { x: infoX + infoMargin, y: height - 120, w: sectionWidth - 2 * infoMargin, h: 30 };
        drawButton(ctx, 'NARRATE FUN FACT', ttsBtn, false, '18px sans-serif');
        mainPanel.userData.tts_button = ttsBtn;
    } else {
        ctx.fillStyle = '#aaa';
        ctx.font = '22px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No target selected.', infoX + sectionWidth / 2, 100);
        delete mainPanel.userData.tts_button;
    }
    
    // Sliders in info panel
    const sliderH = 18;
    mainPanel.userData.timeSlider = { label: 'Time', x: infoX + infoMargin, y: height - 80, w: sectionWidth - (2*infoMargin), h: sliderH, min: 0, max: 20 };
    drawSlider(ctx, mainPanel.userData.timeSlider, timeScale);
    mainPanel.userData.scaleSlider = { label: 'Scale', x: infoX + infoMargin, y: height - 45, w: sectionWidth - (2*infoMargin), h: sliderH, min: 1, max: 10 };
    drawSlider(ctx, mainPanel.userData.scaleSlider, distanceMultiplier);

    mainPanel.userData.texture.needsUpdate = true;
}

function drawSlider(ctx, slider, currentValue) {
    const { label, x, y, w, h, min, max } = slider;
    ctx.fillStyle = '#00ffff';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`${label}: ${currentValue.toFixed(1)}`, x, y - 5);
    ctx.fillStyle = '#004060';
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, w, h);
    const knobX = x + ((currentValue - min) / (max - min)) * w;
    ctx.fillStyle = '#00bfff';
    ctx.fillRect(knobX - 4, y - 2, 8, h + 4);
}

function drawButton(ctx, text, data, isActive, font = '22px sans-serif') {
    ctx.fillStyle = isActive ? '#ffff00' : '#00ffff';
    ctx.font = font;
    const yOffset = font.startsWith('16px') ? 14 : 22;
    ctx.textAlign = 'center';
    ctx.fillText(text, data.x + data.w / 2, data.y + yOffset);
    ctx.strokeStyle = isActive ? '#ffff00' : '#00ffff';
    ctx.strokeRect(data.x, data.y, data.w, data.h);
}

function narrate(text) {
    if (!window.speechSynthesis) return;
    speechSynthesis.cancel();
    speechSynthesis.speak(new SpeechSynthesisUtterance(text));
}

// --- PHYSICS & MOVEMENT ---
function updatePhysics(delta) {
    celestialBodies.forEach(body => {
        if (body.isSun) return;
        
        let pos;
        const data = body.data;
        const M = (clock.elapsedTime * timeScale / data.period) * 2 * Math.PI;

        if (body.isMoon) {
            const parentRadius = body.parentBody.data.radius * BODY_SCALE * SIZE_MULTIPLIER;
            const a_km = data.a * 1e6;
            const aUnit = parentRadius + (a_km * BODY_SCALE);
            pos = getEllipsePosition(aUnit, data.e, M);
            pos.add(body.parentBody.mesh.position);
        } else {
            const aUnit = data.a * 1e6 * BODY_SCALE;
            pos = getEllipsePosition(aUnit, data.e, M);
            pos.multiplyScalar(distanceMultiplier);
        }
        body.mesh.position.copy(pos);
        
        const rotationSpeed = (2 * Math.PI) / (data.period / 365.25);
        body.mesh.rotation.y += rotationSpeed * delta * 50;
    });
}

function getEllipsePosition(a, e, M) {
    let E = M;
    for (let i = 0; i < 5; i++) { E = E - (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E)); }
    const x = a * (Math.cos(E) - e);
    const z = a * Math.sqrt(1 - e * e) * Math.sin(E);
    return new THREE.Vector3(x, 0, z);
}

function warpTo(destination) {
    if (warpSound && !warpSound.isPlaying) warpSound.play();
    const targetPos = destination.mesh.getWorldPosition(new THREE.Vector3());
    const offset = new THREE.Vector3(0, 0, destination.mesh.geometry.parameters.radius * 4 + 10);
    // Apply cockpit rotation to the offset so we always arrive in front
    offset.applyQuaternion(cockpit.quaternion); 
    const endPos = targetPos.add(offset).negate();
    
    // Quick fade transition
    const overlay = new THREE.Mesh(new THREE.PlaneGeometry(2,2), new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0}));
    overlay.position.z = -0.1;
    camera.add(overlay);
    let elapsed = 0;
    const duration = 0.5;
    function fade() {
        elapsed += clock.getDelta();
        if (elapsed <= duration) {
            overlay.material.opacity = elapsed / duration;
            requestAnimationFrame(fade);
        } else if (elapsed <= duration * 2) {
            solarGroup.position.copy(endPos);
            overlay.material.opacity = 1 - (elapsed - duration) / duration;
            requestAnimationFrame(fade);
        } else {
            camera.remove(overlay);
        }
    }
    requestAnimationFrame(fade);
}

// --- RENDER LOOP ---
function animate() {
    const delta = clock.getDelta();
    const effDelta = delta * timeScale;
    
    handleControls(delta);
    if(renderer.xr.isPresenting) {
        handleHandInteractions(controller1);
        handleHandInteractions(controller2);
    }
    updatePhysics(effDelta);
    updateUIPanels();
    
    renderer.render(scene, camera);
}

// Kick off the simulation
init();
</script>
</body>
</html>
